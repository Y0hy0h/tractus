<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        .hypotheses {
            display: flex;
            align-items: flex-start;
        }

        ol {
            padding: 0;
            list-style: none;
        }

        ol.nodes {
            padding-left: 12px;
        }

        .hypotheses>li {
            margin-top: 0.5em;
            padding-right: 12px;
        }

        .hypothesis {
            margin-left: 0.5em;
            font-style: italic;
        }

        .expression {
            font-family: monospace;
            font-weight: bold;
        }

        .hypothesis,
        .expression {
            z-index: 0;
        }

        .expression>* {
            display: inline-block;
            overflow: hidden;
        }

        .variables {
            font-weight: normal;
            margin-right: 0.3em;
            background-color: lightgray;
        }

        .short-info {
            max-width: 12em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .long-info {
            display: none;
        }

        .hypothesis:hover>.long-info,
        .expression:hover>.long-info {
            float: left;
            display: inherit;
            white-space: pre;
            position: absolute;
            background-color: white;
            border: 1px solid black;
            z-index: 2;
            pointer-events: none;
            /* Enables scrubbing through the entries. */
        }

        .hypothesis {
            position: sticky;
            z-index: 1;
            background-color: white;
            top: 0;
            padding: 0.3em;
            margin-top: 2px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /*
         * CONNECTION INDICATOR
         */

        #connection-lost {
            display: none;
        }

        #connection-lost .error {
            color: red;
            font-weight: bold;
        }

        #connection-lost.show-error {
            display: block;
            animation-name: fadeIn;
            animation-duration: 1s;
            animation-delay: 0.25s;
            animation-fill-mode: both;
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <script src="d3js/d3.min.js"></script>
    <script>
        var data;

        let socket = new WebSocket("ws://127.0.0.1:2794", "tractus-websocket");
        socket.onopen = function (event) {
            document.getElementById("connection-lost").setAttribute("class", "");
        };
        socket.onmessage = function (event) {
            console.log("Received new data. (You can inspect it in the global variable `data`.)");
            let parsed = JSON.parse(event.data);
            parsed.root = {
                children: parsed.root,
            };
            data = parsed;
            render(parsed);
        }
        socket.onerror = function (event) {
            console.error(event);
        }
        socket.onclose = function (event) {
            console.warn("Websocket closed.");
            document.getElementById("connection-lost").setAttribute("class", "show-error");
        }

        let width = 1000;

        function make_tree(data) {
            const root = d3.hierarchy(data.root, item => get_children(item, data.hypotheses));
            root.dx = 100;
            root.dy = 25;
            return d3.tree().nodeSize([root.dx, root.dy])(root);
        }

        function render(data) {
            const root = make_tree(data);

            let x0 = Infinity;
            let x1 = -x0;
            root.each(d => {
                if (d.x > x1) x1 = d.x;
                if (d.x < x0) x0 = d.x;
            });

            var rootNode = d3.select('body').selectAll("ol").data([root]).join("ol");
            makeNestedListItems(rootNode);
        }

        function makeNestedListItems(rootNode) {
            let hyps = rootNode.append('ol').classed("hypotheses", true)
                .selectAll('li').data(d => {
                    return d.children || []
                })
                .join("li");
            hyps.each(function (d) {
                if (d.data.hypothesis) {
                    let div = d3.select(this).append("div");
                    div.classed("hypothesis", true);
                    div.append("span").text(d => d.data.hypothesis).classed("short-info", true);
                    div.append("div").classed("long-info", true).text(d.data.hypothesis)
                }
            });
            let nodes = hyps.append("ol").classed("nodes", true)
                .selectAll("li").data(d => {
                    return (d.children)
                }).join("li");

            nodes.each(function (d) {

                let data = d.data.content;
                let div = d3.select(this).append("div").classed("expression", true);
                if (data.assigned_variables.length > 0) {
                    div.append("span").classed("variables", true).text(
                        `${data.assigned_variables.join(" <- ")}`
                    );
                }
                div.append("span").text(d => {
                    if (data.function_name) {
                        return data.function_name + "(…)";
                    } else {
                        return truncate(data.statement, 25);
                    }
                }).classed("short-info", true);
                div.append("div").classed("long-info", true).text(
                    `${data.span.from}: ${data.statement}`
                );
            });
            if (!nodes.empty()) {
                makeNestedListItems(nodes)
            }
        }

        function get_children(item, hypotheses_map) {
            if (item.expressions) {
                return item.expressions
            } else if (item.children) {
                const hyps = item.children;
                const children = Object.keys(hyps).map(
                    key => {
                        return {
                            hypothesis: hypotheses_map[key].join(", "),
                            expressions: hyps[key]
                        };
                    }
                );
                return children;
            }
        }

        function truncate(str, n) {
            return str.substr(0, n - 1) + (str.length > n ? '…' : '');
        }
    </script>
    <div id="connection-lost" class="show-error">
        <p class="error">Not connected to Tractus!</p>
        <p>Ensure that Tractus is running and reload this page.</p>
    </div>
</body>

</html>