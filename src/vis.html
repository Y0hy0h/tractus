<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        .hypotheses {
            display: flex;
            align-items: flex-start;
        }

        ol {
            padding: 0;
            list-style: none;
        }

        ol.nodes {
            padding-left: 12px;
        }

        .hypotheses>li {
            margin-top: 0.5em;
            padding-right: 12px;
        }

        .hypothesis {
            margin-left: 0.5em;
            font-style: italic;
        }

        .expression {
            font-family: monospace;
            font-weight: bold;
        }

        .hypothesis,
        .expression {
            z-index: 0;
        }

        .expression>* {
            display: inline-block;
            overflow: hidden;
        }

        .variables {
            font-weight: normal;
            margin-right: 0.3em;
            background-color: lightgray;
        }

        .short-info {
            max-width: 12em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .long-info {
            display: none;
        }

        .hypothesis:hover>.long-info,
        .expression:hover>.long-info {
            float: left;
            display: inherit;
            white-space: pre;
            position: absolute;
            background-color: white;
            border: 1px solid black;
            z-index: 2;
            pointer-events: none;
            /* Enables scrubbing through the entries. */
        }

        .hypothesis {
            position: sticky;
            z-index: 1;
            background-color: white;
            top: 0;
            padding: 0.3em;
            margin-top: 2px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        /*
        * Directory lines inspired by https://two-wrongs.com/draw-a-tree-structure-with-only-css.
        */
        ol.nodes>li {
            position: relative;
        }

        ol.nodes>li::before,
        ol.nodes>li::after {
            content: "";
            position: absolute;
            left: -12px;
        }

        ol.nodes>li::before {
            border-top: 1px solid #000;
            width: 8px;
            height: 0;
            transform: translateY(10px);
        }

        ol.nodes>li::after {
            border-left: 1px solid #000;
            height: 100%;
            width: 0;
            top: 2px;
        }

        ol.nodes>li:last-child::after {
            height: 8px;
        }

        .hypotheses>li {
            position: relative;
        }

        ol.hypotheses>li::before,
        ol.hypotheses>li::after {
            content: "";
            position: absolute;
            top: 0;
        }

        ol.hypotheses>li::before {
            border-left: 1px solid #000;
            width: 0;
            height: 100%;
        }

        ol.hypotheses>li::after {
            border-top: 1px solid #000;
            width: 100%;
            height: 0;
            left: 0;
        }

        ol.hypotheses>li:first-child::before {
            transform: translateY(-8px);
        }

        ol.hypotheses>li:last-child::after {
            width: 0;
        }
    </style>
</head>

<body>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
        var data;

        let socket = new WebSocket("ws://127.0.0.1:2794", "tractus-websocket");
        socket.onmessage = function (event) {
            console.log("Received data.");
            let parsed = JSON.parse(event.data);
            parsed.root = parsed.root = {
                hypotheses: parsed.root,
            };
            data = parsed;
            console.log(parsed);
            render(parsed);
        }
        socket.onerror = function (event) {
            console.error(event);
        }
        socket.onclose = function (event) {
            console.warn("Websocket closed.");
        }

        let width = 1000;

        function make_tree(data) {
            const root = d3.hierarchy(data.root, item => get_children(item, data.hypotheses));
            root.dx = 100;
            root.dy = 25;
            return d3.tree().nodeSize([root.dx, root.dy])(root);
        }

        function render(data) {
            const root = make_tree(data);

            let x0 = Infinity;
            let x1 = -x0;
            root.each(d => {
                if (d.x > x1) x1 = d.x;
                if (d.x < x0) x0 = d.x;
            });

            var rootNode = d3.select('body').selectAll("ol").data([root]).join("ol");
            makeNestedListItems(rootNode);
        }

        function makeNestedListItems(rootNode) {
            let hyps = rootNode.append('ol').classed("hypotheses", true)
                .selectAll('li').data(d => {
                    return d.children || []
                })
                .join("li");
            hyps.each(function (d) {
                if (d.data.hypothesis) {
                    let div = d3.select(this).append("div");
                    div.classed("hypothesis", true);
                    div.append("span").text(d => d.data.hypothesis).classed("short-info", true);
                    div.append("div").classed("long-info", true).text(d.data.hypothesis)
                }
            });
            let nodes = hyps.append("ol").classed("nodes", true)
                .selectAll("li").data(d => {
                    return (d.children)
                }).join("li");

            nodes.each(function (d) {
                let data = d.data.expression;
                let div = d3.select(this).append("div").classed("expression", true);
                // if (data.assigned_variables.length > 0) {
                //     div.append("span").classed("variables", true).text(
                //         `${data.assigned_variables.join(" <- ")}`
                //     );
                // }
                div.append("span").text(d => {
                    return data;
                    // if (data.function_name) {
                    //     return data.function_name + "(…)";
                    // } else {
                    //     return truncate(data.statement, 25);
                    // }
                }).classed("short-info", true);
                // div.append("div").classed("long-info", true).text(
                //     `${data.index}: ${data.statement}`
                // );
            });
            if (!nodes.empty()) {
                makeNestedListItems(nodes)
            }
        }

        function get_children(item, hypotheses_map) {
            if (item.expressions) {
                return item.expressions
            } else if (item.hypotheses) {
                const hyps = item.hypotheses;
                const children = Object.keys(hyps).map(
                    key => {
                        return {
                            hypothesis: hypotheses_map[key].join(", "),
                            expressions: hyps[key]
                        };
                    }
                );
                return children;
            }
        }

        function truncate(str, n) {
            return str.substr(0, n - 1) + (str.length > n ? '…' : '');
        }
    </script>
</body>

</html>