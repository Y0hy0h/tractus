<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/themes/prism.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />

    <style>
        :root {
            --column-width: 12em;
            --border-color: rgba(0, 0, 0, 0.2);
            --color-hover-background: rgba(0, 0, 0, 0.05);
        }

        html {
            height: 100%;
        }

        body {
            font-family: sans-serif;
            padding: 0;
            margin: 0;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        main {
            flex: 1;
            overflow: auto;
        }

        ol {
            padding: 0;
            list-style: none;
        }

        #control {
            border: 1px solid rgba(0, 0, 0, 0.2);
            padding: 0.3em;
        }

        #control>*+* {
            margin-top: 0.5em;
        }

        #control.empty summary::after {
            content: " (currently nothing is selected)";
        }

        #replacements>h1 {
            font-size: 1rem;
            margin: 0;
        }

        #replacements {
            display: flex;
            flex-direction: column;
            margin-top: 1em;
            margin-bottom: 0.5em;
        }

        #replacements label {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        #replacements>*+* {
            margin-top: 0.5em;
        }

        #replacements.empty {
            display: none;
        }

        button,
        input[type="submit"] {
            border: 1px solid var(--border-color);
            background-color: white;
            padding: 0.2rem;
            padding-left: 0.4rem;
            padding-right: 0.4rem;
        }

        button:hover,
        input[type="submit"]:hover {
            background-color: hsl(0, 0%, 95%);
        }

        .hypotheses-name {
            font-size: 0.9rem;
        }

        #toolbar {
            display: flex;
            flex-direction: column;
            padding: 1em;
            padding-top: 0.5em;
            background: white;
            border-bottom: 1px solid var(--border-color);
        }

        #toolbar>*+* {
            margin-top: 1em;
        }

        #connection-status>* {
            display: inline-block;
        }

        .legend {
            flex: 1;
            border: 1px solid rgba(0, 0, 0, 0.2);
            padding: 0.3em;
            overflow: auto;
            max-height: 25vh;
        }

        .legend summary {
            font-size: 1rem;
            margin: 0;
        }

        .legend>ol {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            margin: 0;
        }

        .legend>ol>li {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            border-top: 5px solid;
            border-left: 1px solid;
            margin: 0.5em;
            padding: 0.2em;
        }

        .legend>ol>li:hover {
            background-color: var(--color-hover-background);
            cursor: pointer;
        }

        summary {
            cursor: pointer;
        }

        .block>ol {
            margin-left: 1em;
        }

        .block>summary>.short-info {
            font-family: monospace;
            white-space: pre;
            color: darkgreen;
            vertical-align: top;
            max-width: var(--column-width);
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .block>summary:hover {
            background-color: var(--color-hover-background);
        }

        .hypotheses {
            display: flex;
            align-items: flex-start;
            padding-left: 1.1rem;
        }

        .nodes {
            grid-area: nodes;
            padding-left: 0.3rem;
            display: grid;
            grid-template-columns: auto;
            grid-gap: 0.1em;
        }

        .hypothesis-container {
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        .selected {
            border: 1px solid black;
        }

        .hypotheses>li {
            border-top: 5px solid rgba(0, 0, 0, 0.1);
            border-left: 1px solid;
            margin-bottom: 0.5em;
            padding-right: 1em;
        }

        .hypothesis {
            grid-area: hypothesis;
            max-width: var(--column-width);
            position: relative;
        }

        .expression-container {
            max-width: var(--column-width);
        }

        .expression {
            font-family: monospace;
            display: inline-block;
            vertical-align: middle;
        }

        .expression .suppressed {
            opacity: 0.4;
        }

        .expression-container:hover .suppressed {
            opacity: 1;
        }

        .expression:hover {
            cursor: pointer;
        }

        .expression>* {
            display: inline-block;
            overflow: hidden;
        }

        .variables {
            font-weight: bold;
            background-color: darkslategray;
            color: white;
            font-size: 0.8rem;
            display: inline-block;
            padding: 0.1rem;
            padding-left: 0.2rem;
            padding-right: 0.2rem;
        }

        .assign {
            margin-left: 0.3em;
            margin-right: 0.3em;
        }

        .hypothesis,
        .expression {
            position: relative;
        }

        /*
         *
         * INFORMATION HOVER
         *
         */

        .short-info {
            position: relative;
            display: inline-block;
            max-width: var(--column-width);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.9rem;
        }

        .long-info {
            position: absolute;
            left: 0;
            top: 100%;
            display: block;
            visibility: hidden;
            white-space: pre;
            background: white;
            width: min-content;
            padding: 0.3em;
            border: 1px solid black;
            z-index: 2;
            pointer-events: none;
            font-size: 0.9rem;
        }

        .hypothesis>.short-info {
            padding: 0.3em;
            border: 1px solid transparent;
        }

        .hypothesis>.long-info {
            top: 0;
        }

        .expression-container:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .hypothesis:hover>.long-info,
        .expression:hover>.long-info {
            display: inherit;
            visibility: visible;
        }

        /*
         *
         * CONNECTION INDICATOR
         *
         */

        #connected.show-error {
            display: none;
        }

        #connection-lost {
            display: none;
        }

        #connection-lost .error {
            color: red;
            font-weight: bold;
        }

        #connection-lost.show-error {
            display: inline-block;
            animation-name: fadeIn;
            animation-duration: 1s;
            animation-delay: 0.25s;
            animation-fill-mode: both;
        }

        .show-error {
            vertical-align: top;
        }

        .show-error p {
            margin: 0;
            margin-bottom: 0.5em;
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }
        }
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-r.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/line-numbers/prism-line-numbers.min.js"></script>

    <script src="https://d3js.org/d3.v5.min.js"></script>

    <script>
        var data;
        var selection = new Set([]);

        let socket = new WebSocket("ws://127.0.0.1:2794", "tractus-websocket");
        socket.onopen = function (event) {
            document.getElementById("toolbar").setAttribute("open", "");
            document.getElementById("connection-lost").setAttribute("class", "");
            document.getElementById("connected").setAttribute("class", "");
        };
        socket.onmessage = function (event) {
            console.log("Received new data. (You can inspect it in the global variable `data`.)");
            let parsed = JSON.parse(event.data);
            parsed.hypothesis_tree.root = {
                Single: { children: parsed.hypothesis_tree.root }
            };
            parsed.hypothesis_tree.hypotheses = color_hypotheses(parsed.hypothesis_tree.hypotheses);
            data = parsed;
            render(parsed);
        }
        socket.onerror = function (event) {
            console.error(JSON.stringify(event));
        }
        socket.onclose = function (event) {
            console.warn("Websocket closed.");
            document.getElementById("toolbar").removeAttribute("open");
            document.getElementById("connection-lost").setAttribute("class", "show-error");
            document.getElementById("connected").setAttribute("class", "show-error");
        }

        let width = 1000;

        function make_tree(hypothesis_tree) {
            const root = d3.hierarchy(hypothesis_tree.root, item => get_children(item, hypothesis_tree.hypotheses));
            root.dx = 100;
            root.dy = 25;
            return d3.tree().nodeSize([root.dx, root.dy])(root);
        }

        function render(data) {
            let hypothesis_tree = data.hypothesis_tree;
            const root = make_tree(hypothesis_tree);

            let hyps = Object.entries(hypothesis_tree.hypotheses).filter((h) => h[1].hypothesis.length > 0);
            if (hyps.length > 0) {
                let legend_hyp = d3.select(".legend ol").selectAll("li").data(hyps).join("li")
                    .style("border-color", (d) => d[1].color)
                    .join("span").classed("hypotheses-name", true).text((d) => d[1].hypothesis.join(", "))
                    .on("click", (d) => {
                        d3.selectAll(`.expression.hyp-id-${d[0]}`).each(function () { nodeClicked(this) });
                    });
            }
            let rootNode = d3.select("#hypothesis-tree").data([root]);
            makeNestedListItems(rootNode, data.statements, hypothesis_tree.hypotheses, hypothesis_tree.blocks);

            Prism.highlightAll();
        }

        function makeNestedListItems(rootNode, stmt_map, hyp_map, block_map) {
            let hyps = rootNode.classed("hypotheses", true)
                .selectAll('li').data(d => {
                    return d.children || []
                })
                .join("li");
            hyps.each(function (d) {
                let hyp_id = d.data.hypothesis_id;
                let hyp = hyp_map[d.data.hypothesis_id];
                let hypColor = hyp.color || "white";
                let li = d3.select(this);
                li.style("border-color", hypColor == "white" ? "rgba(0, 0, 0, 0.1)" : hypColor);
                if (hyp.hypothesis != "") {
                    let div = d3.select(this).append("div").classed("hypothesis-container", true);
                    let hypDisplay = hyp.hypothesis.join(", ");
                    h = div.append("div").classed("hypothesis", true);
                    h.append("span").classed("hypotheses-name", true).text(hypDisplay).classed("short-info", true)
                        .on("click", function (d) {
                            if (d3.event.target == this) {
                                d3.event.stopPropagation();
                                li.selectAll(`.hyp-id-${hyp_id}`).each(function () {
                                    nodeClicked(this);
                                })
                            }
                        });
                    if (hypDisplay != "") {
                        h.append("div").classed("long-info", true).text(hypDisplay)
                    }
                }
                let nodes = d3.select(this).append("ol").classed("nodes", true)
                    .selectAll("li").data(d => d.children).join("li");

                nodes.each(function (d) {
                    makeNode.call(this, d, hyp_id, stmt_map, hyp_map, block_map);
                });
            });
        }

        function makeNode(d, hyp_id, stmt_map, hyp_map, block_map) {
            let node = d3.select(this);
            d.data.hyp_id = hyp_id;
            if (d.data.Group) {
                let data = d.data.Group;
                let block = block_map[data.header].map(stmt_id => stmt_map[stmt_id].statement).join("\n");
                let group = node.append("details").attr("open", "").classed("block", true);
                group.append("summary").append("span").classed("short-info", true).text(block)
                    .on("click", function () {
                        d3.event.preventDefault();
                        d3.event.stopPropagation();
                        group.selectAll(`.hyp-id-${hyp_id}`).each(function () {
                            nodeClicked(this);
                        });
                    });
                group.append("ol").selectAll("li").data(d => d.children).join("li").each(function (d) {
                    makeNode.call(this, d, hyp_id, stmt_map, hyp_map, block_map);
                });
            } else { // is statement
                let data = stmt_map[d.data.Single.content];
                let exp_container;
                if (d.children && d.children.length > 0) {
                    node = node.append("details").attr("open", "");
                    exp_container = node.append("summary");
                } else {
                    exp_container = node.append("div");
                }
                exp_container.classed("expression-container", true);
                let exp_div = exp_container.append("div").classed("expression", true)
                    .classed(`hyp-id-${hyp_id}`, true);
                exp_div.on("click", function () {
                    nodeClicked(this);
                    d3.event.preventDefault();
                    d3.event.stopPropagation();
                })
                let short_info = exp_div.append("div").classed("short-info", true);
                if (data.assigned_variables.length > 0) {
                    short_info.append("span").classed("variables", true).text(
                        `${data.assigned_variables.join(" <- ")}`
                    );
                    short_info.append("span").classed("assign", true).text("<-");
                }
                let isSuppressed = ["print", "cat"].includes(data.function_name);
                short_info.append("code").classed("language-r", true).classed("suppressed", isSuppressed || null).text(d => {
                    if (data.function_name) {
                        return data.function_name + "(…)";
                    } else {
                        return truncate(data.statement, 25);
                    }
                });
                let longInfo = exp_div.append("div").classed("long-info", true);
                longInfo.append("pre").attr("data-start", data.span.from).append("code").classed("language-r", true)
                    .classed("line-numbers", true).text(data.statement);
                if (data.meta && data.meta.result != "") {
                    longInfo.append("span").classed("result").text(data.meta.result);
                }

                if (d.children && d.children.length > 0) {
                    let hyps = node.append("ol");
                    makeNestedListItems(hyps, stmt_map, hyp_map, block_map);
                }
            }
        }

        function get_children(item, hypotheses_map) {
            if (item.expressions) {
                return item.expressions
            } else if (item.Single) {
                const hyps = item.Single.children;
                const children = Object.keys(hyps).map(
                    key => {
                        return {
                            hypothesis_id: key,
                            expressions: hyps[key]
                        };
                    }
                );
                return children;
            } else if (item.Group) {
                return item.Group.elements;
            }
        }

        function truncate(str, n) {
            return str.substr(0, n - 1) + (str.length > n ? '…' : '');
        }

        function color_hypotheses(hyps) {
            let number_of_hyps = Object.keys(hyps).length;
            let color_step = 360 / (number_of_hyps - 1);

            for (let [key, value] of Object.entries(hyps)) {
                if (key == 0) {
                    hyps[key] = {
                        hypothesis: value,
                        color: "white"
                    }
                } else {
                    let hue = (key - 1) * color_step;
                    let color = `hsl(${hue}, 80%, 80%)`;
                    hyps[key] = {
                        hypothesis: value,
                        color: color
                    }
                }
            }

            return hyps;
        }

        function nodeClicked(node) {
            let n = d3.select(node);
            if (n.classed("selected")) {
                selection.delete(node);
                n.classed("selected", false);
            } else {
                selection.add(node);
                n.classed("selected", true)
            }

            updateSelectedHypotheses();
            updateButtons();
        }

        function updateButtons() {
            let isSelectionEmpty = selection.size == 0;
            d3.selectAll("#repro, #replace").attr("disabled", isSelectionEmpty ? true : null);
            d3.select("#control").classed("empty", isSelectionEmpty);

        }

        function reproCodeForSelected() {
            let dependencies = new Set([]);
            for (n of selection) {
                let id = d3.select(n).datum().data.Single.content;
                for (a of ancestors(id)) {
                    dependencies.add(a);
                }
            }
            dependencies = Array.from(dependencies);
            dependencies.sort((l, r) => l - r); // Sort numerically.
            let reproCode = dependencies.map(t => data.statements[t].statement).join("\n")
            console.log(reproCode);
            navigator.clipboard.writeText(reproCode);

            clearSelection();
        }

        function updateSelectedHypotheses() {
            let hypIds = Array.from(new Set(Array.from(selection).map(n => d3.select(n).datum().data.hyp_id)));
            hypIds.sort((a, b) => a - b);// Sort numerically.
            let hyps = hypIds.map(id => data.hypothesis_tree.hypotheses[id].hypothesis)
                .flatMap(hyps => hyps.map(hyp => hyp.match(/(.+) ~ (.+)/)));
            let dependent = new Set([]);
            //let independent = new Set([]);
            for (hyp of hyps) {
                dependent.add(hyp[1]);
                dependent.add(hyp[2]);
            }

            d3.select("#replacements").selectAll("label").data(Array.from(dependent)).join("label")
                .text(d => d).append("input").classed("hyp-replacement", true)
                .attr("type", "text").attr("value", d => d).attr("name", d => d).attr("required", "true");

            d3.select("#replacements").classed("empty", hyps.length == 0);
        }

        function doReplace(event) {
            event.preventDefault();
            let inputs = d3.selectAll("#replacements .hyp-replacement").nodes();
            if (inputs.findIndex(n => n.value == "") != -1) {
                console.warn("Submitted replace form with empty values.")
            } else {
                let code = Array.from(selection).map(n => d3.select(n).datum().data.Single.content);
                code.sort((l, r) => l - r); // Sort numerically.
                code = code.map(id => data.statements[id].statement);
                for (n of inputs) {
                    let previous = n.name;
                    let replacement = n.value;
                    code = code.map(line => line.replace(new RegExp(previous), replacement));
                }
                code = code.join("\n");
                console.log(code);
                navigator.clipboard.writeText(code);

                clearSelection();
            }
        }

        function clearSelection() {
            for (n of selection) {
                d3.select(n).classed("selected", false);
            }
            selection = new Set([]);

            updateSelectedHypotheses();
            updateButtons();
        }

        function ancestors(id) {
            let a = new Set([id]);
            let new_a;
            do {
                new_a = a;
                for (id of a) {
                    for (p_id of parents(id)) {
                        new_a.add(p_id);
                    }
                }
            } while (a != new_a)
            return a;
        }

        function parents(id) {
            let p = new Set([]);
            for (edge of data.dependencies.edges) {
                if (edge[1] == id) {
                    p.add(edge[0]);
                }
            }
            return p;
        }
    </script>
    <details id="toolbar">
        <summary id="connection-status">
            <div id="connected" class="show-error">
                ✔️️ Connected to Tractus.
            </div>
            <div id="connection-lost" class="show-error">
                <p class="error">❌ Not connected to Tractus!</p>
                <p>Ensure that Tractus is running and reload this page.</p>
            </div>
        </summary>
        <details class="legend" open onclick="arguments[0].stopPropagation()">
            <summary>Hypotheses explored</summary>
            <ol></ol>
        </details>
        <details id="control" class="empty">
            <summary>Process selection</summary>
            <button id="repro" onclick="reproCodeForSelected()" disabled="true">
                Copy reproduction code
            </button>
            <form id="hyp-replace" onsubmit="doReplace(arguments[0])">
                <details id="replacements" class="empty">
                    <summary>Variable replacements</summary>
                </details>
                <input type="submit" id="replace" value="Copy with replaced hypotheses" disabled="true" />
            </form>
            </aside>
        </details>
    </details>
    <main>
        <ol id="hypothesis-tree"></ol>
    </main>
</body>
</html>